<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>DS Interview Study Guide Part II: Software Engineering - Ramya Bygari</title>
<meta name="description" content="Part II of my guide to data science interviews, focusing on algorithms, data structures, and general programming knowledge and best practices.">


  <meta name="author" content="Ramya Bygari">
  
  <meta property="article:author" content="Ramya Bygari">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Ramya Bygari">
<meta property="og:title" content="DS Interview Study Guide Part II: Software Engineering">
<meta property="og:url" content="http://localhost:4000/posts/2019/08/29/engineering.html">


  <meta property="og:description" content="Part II of my guide to data science interviews, focusing on algorithms, data structures, and general programming knowledge and best practices.">







  <meta property="article:published_time" content="2019-08-29T00:00:00+05:30">






<link rel="canonical" href="http://localhost:4000/posts/2019/08/29/engineering.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Ramya Bygari Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Ramya Bygari
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/">Home</a>
            </li><li class="masthead__menu-item">
              <a href="/about/">About</a>
            </li><li class="masthead__menu-item">
              <a href="/portfolio/">Portfolio</a>
            </li><li class="masthead__menu-item">
              <a href="/experience/">Experience</a>
            </li><li class="masthead__menu-item">
              <a href="/assets/docs/resume.pdf">Resume</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person" class="h-card">

  
    <div class="author__avatar">
      <a href="http://localhost:4000/">
        <img src="/assets/images/Ramya.png" alt="Ramya Bygari" itemprop="image" class="u-photo">
      </a>
    </div>
  

  <div class="author__content">
    <h3 class="author__name p-name" itemprop="name">
      <a class="u-url" rel="me" href="http://localhost:4000/" itemprop="url">Ramya Bygari</a>
    </h3>
    
      <div class="author__bio p-note" itemprop="description">
        <p>Machine Learning and Scalable Systems</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name" class="p-locality">Bangalore, India</span>
        </li>
      

      

      

      
        <li>
          <a href="mailto:ramyabygari239@gmail.com" rel="me" class="u-email">
            <meta itemprop="email" content="ramyabygari239@gmail.com" />
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span>
          </a>
        </li>
      

      

      

      

      
        <li>
          <a href="https://www.linkedin.com/in/ramyabygari" itemprop="sameAs" rel="nofollow noopener noreferrer me">
            <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span class="label">LinkedIn</span>
          </a>
        </li>
      

      

      

      

      

      
        <li>
          <a href="https://github.com/ramyabygari" itemprop="sameAs" rel="nofollow noopener noreferrer me">
            <i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span>
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer me">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>
  
  </div>



  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="DS Interview Study Guide Part II: Software Engineering">
    <meta itemprop="description" content="Part II of my guide to data science interviews, focusing on algorithms, data structures, and general programming knowledge and best practices.">
    <meta itemprop="datePublished" content="2019-08-29T00:00:00+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title p-name" itemprop="headline">
            <a href="http://localhost:4000/posts/2019/08/29/engineering.html" class="u-url" itemprop="url">DS Interview Study Guide Part II: Software Engineering
</a>
          </h1>
          


        </header>
      

      <section class="page__content e-content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> Contents</h4></header>
              <ul class="toc__menu"><li><a href="#what-languages-should-i-know">What Languages Should I Know?</a></li><li><a href="#general-tips-for-coding-interviews">General Tips for Coding Interviews</a><ul><li><a href="#how-to-prepare">How to Prepare</a></li><li><a href="#tips-for-interviewing">Tips for Interviewing</a></li><li><a href="#tips-for-coding">Tips for Coding</a></li></ul></li><li><a href="#working-with-data">Working with Data</a><ul><li><a href="#loading--cleaning-data">Loading &amp; Cleaning Data</a></li><li><a href="#visualization">Visualization</a></li></ul></li><li><a href="#data-structures--algorithms">Data Structures &amp; Algorithms</a><ul><li><a href="#time-and-space-complexity-analysis">Time and Space Complexity Analysis</a></li><li><a href="#arrays--hashmaps">Arrays &amp; Hashmaps</a></li><li><a href="#sorting--searching">Sorting &amp; Searching</a><ul><li><a href="#sorting">Sorting</a></li><li><a href="#searching">Searching</a></li></ul></li></ul></li><li><a href="#working-with-sql">Working with SQL</a><ul><li><a href="#a-note-on-dialects">A Note on Dialects</a></li></ul></li><li><a href="#conclusion">Conclusion</a></li></ul>

            </nav>
          </aside>
        
        <p>This post continues my series on data science interviews. One of the major difficulty of
doing data science interviews is that you must show expertise in a wide variety of
skills. In particular, I see four key subject areas that you might be asked about during
an interview:</p>

<ol>
  <li>Statistics</li>
  <li>Software Engineering/Coding</li>
  <li>Machine Learning</li>
  <li>“Soft” Questions</li>
</ol>

<p>This post focuses on software engineering &amp; coding. It will be primarily a resource for
aggregating content that I think you should be familiar with. I will mostly point to
outside sources for technical exposition and practice questions.</p>

<p>I’ll link to these as appropriate throughout the post, but I thought it would be helpful
to put up front a list of the primary resources that I’ve used when studying for
interviews. Some of my favorites are:</p>

<ul>
  <li><a href="https://www.amazon.com/Structures-Algorithms-Python-Michael-Goodrich/dp/1118290275/">Data Structures and Algorithms in Python</a>, for a good introduction to
data structures such as linked lists, arrays, hashmaps, and so on. It also can give
you good sense of how to write idiomatic Python code, for building fundamental
classes.</li>
  <li><a href="https://sqlzoo.net/">SQLZoo</a> for studying SQL and doing practice questions. I particularly like
the “assessments”.</li>
  <li><a href="http://www.crackingthecodinginterview.com/">Cracking the Coding Interview</a> for lots of practice questions organized by
subject, and good general advice for the technical interviewing process.</li>
</ul>

<p>I also use coding websites like LeetCode to practice various problems. I also look on
Glassdoor to see <a href="https://www.glassdoor.com/Interview/san-francisco-data-scientist-interview-questions-SRCH_IL.0,13_IM759_KO14,28.htm">what kinds of problems</a> people have been asked.</p>

<p>As always, I’m working to improve this post, so please do leave comments with feedback.</p>

<h1 id="what-languages-should-i-know">What Languages Should I Know?</h1>

<p>In this section of data science interviews, your are generally asked to implement things
in code. So, which language should you do it in? Generally, the best answer is
(unsurprisingly) that <strong>you should work in Python</strong>. The next most popular choice is R;
I’m not very familiar with R, so I can’t really speak to it’s capabilities.</p>

<p>There are a few reasons you should work in Python:</p>

<ol>
  <li>It’s widely adopted within industry.</li>
  <li>It has high-quality, popular packages for working with data (see <code class="highlighter-rouge">pandas</code>, <code class="highlighter-rouge">numpy</code>,
<code class="highlighter-rouge">scipy</code>, <code class="highlighter-rouge">statsmodels</code>, <code class="highlighter-rouge">scikit-learn</code>, <code class="highlighter-rouge">matplotlib</code>, etc).</li>
  <li>It bridges the gap between academic work (e.g. using NumPy to build a fast solver for
differential equations) and industrial work (e.g. using Django to build webservices).</li>
</ol>

<p>This is far from an exhaustive list. Anyways, I mostly work in Python. I think it’s a
nice language because it is clear and simple to write.</p>

<p>If you want to use another language, you should make sure that you can do everything you
need to - this includes reading &amp; writing data, cleaning/munging data, plotting,
implementing statistical and machine learning models, and leveraging basic data types
like hashmaps and arrays (more on those later).</p>

<p>I think if you wanted to do your interviews in R it would be fine, so long as you can do
the above. I would strongly recommend against languages like MATLAB, which are
proprietary and not open-source.</p>

<p>Languages like Java can be tricky since they might not have the data-oriented libraries
that Python has. For example, I’ve worked profesionally in Scala, and am very
comfortable manipulating data via the Spark API within it, but still wouldn’t want to
have to use it in an interview; it just isn’t as friendly for general-purpose hacking as
Python.</p>

<p>So is Python all you need? Well, not quite. You should also be familiar with SQL for
querying databases; we’ll get into that later. I don’t think the dialect you use
particularly matters. <a href="https://sqlzoo.net/">SQLZoo</a> works with MySQL, which is fine. Familiarity with
bash and shell-scripting is useful for a data scientist in their day-to-day work, but
generally isn’t asked about in interviews. For the interviews, I’d say if you know one
general-purpose language (preferably Python, or R if need be) and SQL, then you’ll be
fine.</p>

<h1 id="general-tips-for-coding-interviews">General Tips for Coding Interviews</h1>

<p>Coding interviews are notorious for being high-stress, so it’s important that you
practice in a way that will maximize your comfort during the interview itself - you
don’t want to add any unnecessary additional stress into an already difficult
situation. There are a wide variety of philosophies and approaches to preparing yourself
for and executing a successful interview. I’m going to talk about some points that
resonate with me, but I’d also recommend reading <a href="http://www.crackingthecodinginterview.com/">Cracking the Coding Interview</a>
for a good discussion. Of course, this isn’t the final word on the topic - there are
endless resources available online that address this.</p>

<h2 id="how-to-prepare">How to Prepare</h2>

<p>When preparing for the interview, make sure to practice in an environment similar to the
interview environment. There are a few aspects of this to keep in mind.</p>

<ul>
  <li>Make sure that you replicate the <strong>writing environment</strong> of the interview. So, if
you’ll be coding on a whiteboard, try to get access to a whiteboard to practice. At
least practice on a pad of paper, so that you’re comfortable with handwriting code -
it’s really quite different than using a text editor. If you’ll be coding in a Google
Doc, practice doing that (protip: used a monospaced font). Most places I’ve
interviewed at don’t let you evaluate your code to test it, so you have to be prepared
for that.</li>
  <li><strong>Time yourself!</strong> It’s important to make sure you can do these things in a reasonable
amount of time. Generally, these things last 45 minutes per “round” (with multiple
rounds for on-site interviews). Focus on being efficient at implementing simple ideas,
so that you don’t waste a bunch of time with your syntax and things like that.</li>
  <li><strong>Practice talking.</strong> If you practice by coding silently by yourself, then it might
feel strange when you’re in the interview and have to talk through your process. The
best is if you can have a friend who is familiar with interviewing play the
interviewer, so that you can talk to them, get asked questions, etc. You can also
record yourself and just talk to the recorder, so that you get practice externalizing
your thoughts.</li>
</ul>

<p>There are some services online that will do “practice” interviews for you. When I was
practicing for a software engineer interview with Google, I used <a href="http://www.gainlo.co/#!/">Gainlo</a> for
this - they were kind of expensive, but you interview with real Google software
engineers, which I found helpful.</p>

<p>However, the interviews for a software engineering position at Google are very
standardized in format. I haven’t used any of the services that do this for data
science, and the interviews you’ll face are so varied. Therefore, I imagine it is harder
to do helpful “mock interviews”. If you’ve used any of these services, I’d be very
curious to hear about your experience.</p>

<h2 id="tips-for-interviewing">Tips for Interviewing</h2>

<p>There are some things it’s important to keep in mind as you do the interview itself.</p>

<ul>
  <li><strong>Talk about your thought process.</strong> Don’t just sit sliently thinking, then go and
write something on the board. Let the interviewer into your mind so that they can see
how you are thinking about the problem. This is good advice at any point in a
technical interview.</li>
  <li><strong>Start with a simple solution you have confidence in.</strong> If you know that you can
quickly write up a suboptimal solution (in this case, maybe insertion sort), then do
that! You can discuss <em>why</em> that solution is sub-optimal, and they will often
brainstorm with you about how to improve it. That said, if you are just as confident
in writing up something more optimal (say, quicksort) then feel free to jump right to
that.</li>
  <li><strong>Sketch out your solution before doing real code.</strong> This is not necessary, but
sometimes for complicated stuff it’s nice to write out your approach in pseudocode
before jumping into real code. This can also help with exposing your thought process
to the interviewer, and making sure they’re on board with how you’re thinking about
it.</li>
  <li><strong>Think about edge cases.</strong> Suppose they ask you to write a function that sorts a
list. What if you’re given an empty list? What if you’re given a list of
non-comparable things? (In Python, this might be a list of lists.) What does your
function do in this case?  Is that what you <em>want</em> it to do? There’s no right answer
here, but you should definitely be thinking about this and asking the interview how
they want the function to behave on these cases.</li>
  <li><strong>Be sure to do a time complexity analysis on your solution.</strong> They want to know that
you can think about efficiency, so unless they explicitly ask you not to do this, I’d
recommend it. We’ll discuss more about what this means below.</li>
</ul>

<p>For a more thorough discussion of preparation and day-of techniques, I’d recommend
<a href="http://www.crackingthecodinginterview.com/">Cracking the Coding Interview</a>.</p>

<h2 id="tips-for-coding">Tips for Coding</h2>

<p>There are few things specifically in how the interviewee writes code that I think are
worth mentioning. This kind of stuff usually isn’t a huge deal, but if you write good
code, it can show professionalism and help leave a good impression.</p>

<ul>
  <li><strong>Name your variables well.</strong> If the variable is the average number of users per
region, use <code class="highlighter-rouge">num_users_per_region</code>, or <code class="highlighter-rouge">users_per_region</code>, not <code class="highlighter-rouge">avg_usr</code> or
<code class="highlighter-rouge">num_usr</code>. Unlike in mathematics, it’s good to have long, descriptive variables.</li>
  <li><strong>Use built-ins when you can!</strong> Python already <em>has</em> functions for sorting, for
building cartesian products of lists, for implementing various models (in
<code class="highlighter-rouge">statsmodels</code> and <code class="highlighter-rouge">scikit-learn</code>), and endless other things. It also has some cool
data structures already implemented, like the <a href="https://docs.python.org/3.7/library/heapq.html"><code class="highlighter-rouge">heap</code></a> and
<a href="https://docs.python.org/3/library/queue.html"><code class="highlighter-rouge">queue</code></a>. Get to know the <code class="highlighter-rouge">itertools</code> module; it has lots of usefull stuff.
if you can use these built-ins effectively, it demonstrates skill and knowledge
without adding much effort on your part.</li>
  <li><strong>Break things into functions.</strong> If one step of your code is sorting a list, and you
can’t use the built-in <code class="highlighter-rouge">sorted()</code> function, then write a separate function <code class="highlighter-rouge">def
sort()</code> before you write your main function. This increases both readability and
testability of code, and is essential for real-world software.</li>
  <li><strong>Write idiomatic Python.</strong> This is a bit less important, but make sure to iterate
directly over iterables, don’t do <code class="highlighter-rouge">for i in range(len(my_iterable))</code>. Also,
familiarize yourself with <code class="highlighter-rouge">enumerate</code> and <code class="highlighter-rouge">zip</code> and know how to use them. Know how to
use list compreshensions, and be aware that you can do a similar thing for
dictionaries, sets, and even arguments of functions - for example, you can do
<code class="highlighter-rouge">max(item for item in l if item % 2 == 0)</code> to find the maximum even number in l. Know
how to do string formatting using either <code class="highlighter-rouge">.format()</code> for <code class="highlighter-rouge">f</code>-strings in Python
3.<sup id="fnref:fnote_py3"><a href="#fn:fnote_py3" class="footnote">1</a></sup></li>
</ul>

<p>I’m only scratching the surface of how to write good code. It helps to read code that
others have written to see what you don’t know. You can also look at code in large
open-source libraries.</p>

<p>With all that said, let’s move on to some of the content that might be asked about in
these interviews.</p>

<h1 id="working-with-data">Working with Data</h1>

<p>One of the fundamental tasks of a data scientist is to load, manipulate, clean, and
visualize data in various formats. I’ll go through some of the basic tasks that I think
you should be able to do, and either include or link to Python implementations. If you
work in R, or any other language, you should make sure that you can still do these
things in your preferred language.</p>

<p>In Python, the key technologies are the packages pandas (for loading, cleaning, and
manipulating data), numpy (for efficiently working with unlabeled numeric data), and
matplotlib (for plotting and visualizing data).</p>

<h2 id="loading--cleaning-data">Loading &amp; Cleaning Data</h2>

<p><a href="https://www.datacamp.com/community/tutorials/pandas-read-csv">This tutorial on DataCamp</a> nicely deals with the basics of using
<code class="highlighter-rouge">pd.read_csv()</code> to load data into Pandas. It is also possible to load from other
formats, but in my experience writing to and from comma- or tab-separated plaintext is
by far the most common approach for datasets that fit in memory.<sup id="fnref:fnote_parquet"><a href="#fn:fnote_parquet" class="footnote">2</a></sup></p>

<p>For example, suppose you had the following data in a csv file:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>name,age,country,favorite color
steve,7,US,green
jennifer,14,UK,blue
franklin,,UK,black
calvin,22,US,
</code></pre></div></div>

<p>You can copy and paste this, into Notepad or whatever text editor you
like<sup id="fnref:fnote_emacs"><a href="#fn:fnote_emacs" class="footnote">3</a></sup>, and save it as <code class="highlighter-rouge">data.csv</code>.</p>

<p>You should be able to</p>
<ul>
  <li>load in data from text, whether it is separated by commas, tabs, or some other
arbitrary character (sometimes things are separated by the “pipe” character <code class="highlighter-rouge">|</code>). In
this case, you can just do <code class="highlighter-rouge">df = pd.read_csv('data.csv')</code> to load it.</li>
  <li>Filter for missing data. If you wanted to find the row(s) where the age is missing,
for example, you could do <code class="highlighter-rouge">df[df['age'].isnull()]</code></li>
  <li>Filter for data values. For example, to find people from the US, do <code class="highlighter-rouge">df[df['country'] == 'US']</code></li>
  <li>Replace missing data; use <code class="highlighter-rouge">df.fillna(0)</code> to replace missing data with zeros. Think for
yourself about how you would want to handle missing data in this case - does it make
sense to replace everything with zeros? What <em>would</em> make sense?</li>
</ul>

<p>Dealing with missing data is, in particular, an important problem, and not one that has
an easy answer. <a href="https://towardsdatascience.com/how-to-handle-missing-data-8646b18db0d4">Towards Data Science</a> has a decent post on this
subject, but if you’re curious, there’s a lot to read about and learn here.</p>

<p>More advanced topics in pandas-fu include <a href="https://wesmckinney.com/blog/groupby-fu-improvements-in-grouping-and-aggregating-data-in-pandas/">using <code class="highlighter-rouge">groupby</code></a>, joining
dataframes (this is called a “merge” in pandas, but works the same as a SQL join), and
<a href="https://hackernoon.com/reshaping-data-in-python-fa27dda2ff77">reshaping data</a>.</p>

<p>As I said before, loading and manipulating data is one of the fundamental tasks of a
data scientist. You should probably be comfortable doing most or all of these tasks if
asked. Pandas can be a bit unintuitive, so I’d recommend practicing if you aren’t
already comfortable with it. Doing slicing and reshaping tasks in numpy is also an
important skill, so make sure you are comfortable with that as well.</p>

<h2 id="visualization">Visualization</h2>

<p>Another essential aspect of data work is visualization. Of course, this is an entire
field unto itself; here, I’ll mostly be focusing on the practical aspects of making
simple plots. If you want to start to learn more about the overarching principles of the
visual representation of data, <a href="https://www.edwardtufte.com/tufte/books_vdqi">Tufte’s book</a> is the classic in the field.</p>

<p>In Python, the fundamental tool used for data visualization is the library
<code class="highlighter-rouge">matplotlib</code>. There exist many other libraries for more complicated visualization tasks,
such as <code class="highlighter-rouge">seaborn</code>, <code class="highlighter-rouge">bokeh</code>, and <code class="highlighter-rouge">plotly</code>, but the only one that you really <em>need</em> to be
comfortable with (in my opinion) is <code class="highlighter-rouge">matplotlib</code>.</p>

<p>You should be comfortable with:</p>
<ul>
  <li>plotting two lists against one another</li>
  <li>changing the labels on the x- and y-axis of your plot, and adding a title</li>
  <li>changing the x- and y-limits of your plot</li>
  <li>plotting a bar graph</li>
  <li>plotting a histogram</li>
  <li>plotting two curves together, labelling them, and adding a legend</li>
</ul>

<p>I won’t go through the details here - I’m sure you can find many good guides to each of
these online. The <a href="https://matplotlib.org/3.1.1/tutorials/introductory/pyplot.html">matplotlib pyplot tutorial</a> is a good place to
start.<sup id="fnref:fnote_pyplot"><a href="#fn:fnote_pyplot" class="footnote">4</a></sup></p>

<p>It’s worth noting that you can plot directly from pandas, by doing <code class="highlighter-rouge">df.plot()</code>. This
just calls out to matplotlib and plots your dataframe; I will often find myself both
plotting from the pandas <code class="highlighter-rouge">DataFrame.plot()</code> method as well as directly using
<code class="highlighter-rouge">pyplot.plot()</code>. They work on the same objects, and so you can use them together to make
more complicated plots with multiple values plotted.</p>

<h1 id="data-structures--algorithms">Data Structures &amp; Algorithms</h1>

<p>Designing and building effective software is predicated on a solid understanding of the
basic data structures that are available, and familiarity with the ways that they are
employed in common algorithms. For me, learning this material opened up the world of
software engineering - it illuminated the inner workings of computer languages. It also
helped me understand the pros and cons of various approaches to problems, in ways that I
wouldn’t have been able to before.</p>

<p>This subject is fundamental to software engineering interviews, but for data scientists,
its importance can vary drastically from role to role. For engineering-heavy roles, this
material can make up half or more of the interview, while for more statistician-oriented
roles, it might only be very lightly touched upon. You will have to use your judgement
to determine to what extent this material is important to you.</p>

<p>I learned this material when I was interviewing by reading the book <a href="https://www.amazon.com/Structures-Algorithms-Python-Michael-Goodrich/dp/1118290275/">Data Structures and
Algorithms in Python</a>.<sup id="fnref:fnote_dsa2"><a href="#fn:fnote_dsa2" class="footnote">5</a></sup> It’s really a great book - it has good, clear
explanations of all the important topics, including complexity analysis and some of the
basics of the Python language. I can’t recommend it highly enough if you want to get
more familiar with this material.<sup id="fnref:fnote_dsa"><a href="#fn:fnote_dsa" class="footnote">6</a></sup> You can buy it, or look around online for
the PDF - it shouldn’t be too hard to find.</p>

<h2 id="time-and-space-complexity-analysis">Time and Space Complexity Analysis</h2>

<p>Before you begin writing algorithms, you need to know how to analyze their
complexity. The “complexity” of an algorithm tells you how the amount of time (or space)
that the algorithm takes depends on the size of the input data.</p>

<p>It is formalized using the so-called “big-O” notation. The precise mathematical
definition of <script type="math/tex">\mathcal{O}(n)</script> is somewhat confusing, so you can just think of it
roughly as meaning that an algorithm that is <script type="math/tex">\mathcal{O}(n)</script> “scales like <script type="math/tex">n</script>”; so,
if you double the input size, you double the amount of time it takes. If an algorithm is
<script type="math/tex">\mathcal{O}(n^3)</script>, then, doubling the input size means that you multiply the time it
takes by <script type="math/tex">2^3 = 8</script>.<sup id="fnref:fnote_bigo"><a href="#fn:fnote_bigo" class="footnote">7</a></sup> You can see how even a <script type="math/tex">\mathcal{O}(n^2)</script> algorithm wouldn’t
work for large data; even if it runs in a reasonable amount of time (say, 5 seconds)for
10,000 points, it would take about 15,000 years to run on 1 billion data
points. Obviously, this is no good.</p>

<p>So complexity analysis is critical. You don’t want to settle for a <script type="math/tex">\mathcal{O}(n^2)</script>
solution when a <script type="math/tex">\mathcal{O}(n)</script> or <script type="math/tex">\mathcal{O}(n \log n)</script> solution is available. I
won’t get into how to do the analysis here, besides saying that I often like to annotate
my loops with their complexity when I’m writing things. For example, here’s a (slow)
approach to finding the largest k (unique) numbers in a list:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_top_k</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">input_list</span><span class="p">):</span>
    <span class="n">top_k</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>  <span class="c"># happens k times</span>
        <span class="n">remaining</span> <span class="o">=</span> <span class="p">[</span><span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">input_list</span> <span class="k">if</span> <span class="n">num</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">top_k</span><span class="p">]</span>  <span class="c"># O(n)</span>
        <span class="k">if</span> <span class="n">remaining</span><span class="p">:</span>
            <span class="n">top_remaining</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">remaining</span><span class="p">)</span>  <span class="c"># O(n)</span>
            <span class="n">top_k</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top_remaining</span><span class="p">)</span>  <span class="c"># O(1)</span>
    <span class="k">return</span> <span class="n">top_k</span>
</code></pre></div></div>

<p>I know that the outer loop happend <code class="highlighter-rouge">k</code> times, and since finding the maximum of a list is
<script type="math/tex">\mathcal{O}(n)</script>, the total task is <script type="math/tex">\mathcal{O}(nk)</script>.<sup id="fnref:fnote_asymptotics"><a href="#fn:fnote_asymptotics" class="footnote">8</a></sup> To learn
more about how to do complexity analysis, I’d look at <a href="https://www.amazon.com/Structures-Algorithms-Python-Michael-Goodrich/dp/1118290275/">DS&amp;A</a>, <a href="http://www.crackingthecodinginterview.com/">Cracking the
Coding Interview</a>, or just look around online - I’m sure there are plenty of good
resources out there.</p>

<p>You can also consider not just the time of computation, but the amount of memory (space)
that your algorithm uses. This is not quite as common as time-complexity analysis, but
is still important to be able to do.</p>

<p>A very useful resource for anyone studying for a coding interview is the <a href="https://www.bigocheatsheet.com/">big-O cheat
sheet</a>, which shows the complexity of access, search, insertion, and deletion for
various data types, as well as the complexity of searching algorithms, and a lot more. I
often use it as a reference, but of course it’s important that you understand <em>why</em> (for
example) an array has <script type="math/tex">\mathcal{O}(n)</script> insertion. Just memorizing complexities won’t
help you much.</p>

<h2 id="arrays--hashmaps">Arrays &amp; Hashmaps</h2>

<p>In my opinion, the two essential data structures for a data scientist to know are
the array and the hashmap. In Python, the <code class="highlighter-rouge">list</code> type is an array, while the <code class="highlighter-rouge">dict</code> type
is a hashmap. Since both are used so commonly, you have to know their properties if you
want to be able to design efficient algorithms and do your complexity analysis
correctly.</p>

<p><strong>Arrays</strong> are a data type where a piece of data (like a string) is linked to an index
(in Python, this is an integer, starting with 0). I won’t go too deep into the details
here, but for arrays, the important thing to know is that getting any element of an
array is easy (i.e. doing <code class="highlighter-rouge">mylist[5]</code> is <script type="math/tex">\mathcal{O}(1)</script>, so it doesn’t depend on the
size of the array) but adding elements (particularly in the beginning or middle of the
array) is difficult; doing <code class="highlighter-rouge">mylist.insert(k, 'foo')</code> is <script type="math/tex">\mathcal{O}(n-k)</script>, where
<script type="math/tex">k</script> is the position you wish to insert at.<sup id="fnref:fnote_linked"><a href="#fn:fnote_linked" class="footnote">9</a></sup></p>

<p>Arrays are what we usually use when we’re building unordered, unlabelled collections of
objects in Python. This is fine, since insertion at the end of an array is fast, and
we’re often accessing slices of arrays in a complicated fashion (particularly in
numpy). I generally use arrays by default, without thinking too much about it, and it
generally works out alright.</p>

<p><strong>Hashmaps</strong> also link values to keys, but in this case the key can be anything you
want, rather than having to be an ordered set of integers. In Python, you build them by
specifying the key and the value, like <code class="highlighter-rouge">{'key': 'value'}</code>. Hashmaps are magical in that
accessing elements <em>and</em> adding elements are both
<script type="math/tex">\mathcal{O}(1)</script>.<sup id="fnref:fnote_array_hashmap"><a href="#fn:fnote_array_hashmap" class="footnote">10</a></sup> Why is this cool? Well, say you wanted to
store a bunch of people’s names and ages. You might think to do a list of tuples:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">names_ages</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'Peter'</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="p">(</span><span class="s">'Kat'</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span> <span class="p">(</span><span class="s">'Jeff'</span><span class="p">,</span> <span class="mi">41</span><span class="p">)]</span>
</code></pre></div></div>

<p>Then, if you wanted to find out Jeff’s age, you would have to iterate through the list
and find the correct tuple:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span> <span class="ow">in</span> <span class="n">name_ages</span><span class="p">:</span>  <span class="c"># happens n times</span>
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">'Jeff'</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">"Jeff's age is {age}"</span><span class="p">)</span>
</code></pre></div></div>

<p>This is <script type="math/tex">\mathcal{O}(n)</script> - not very efficient. With hashmaps, you can just do</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">name_ages</span> <span class="o">=</span> <span class="p">{</span><span class="s">'Peter'</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="s">'Kat'</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="s">'Jeff'</span><span class="p">:</span> <span class="mi">41</span><span class="p">}</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">"Jeff's age is {name_ages['Jeff']}"</span><span class="p">)</span>  <span class="c"># O(1)! Wow!</span>
</code></pre></div></div>

<p>It might not be obvious how cool this is until you see how to use it in
problems. <a href="http://www.crackingthecodinginterview.com/">Cracking the Coding Interview</a> has lots of good problems on hashmaps,
but I’ll just reproduce some of the classics here. I think it’s worth knowing these,
because they really can give you an intuitive sense of when and how hashmaps are
valuable.</p>

<p>The first classic hashmap algorithm is <strong>counting frequencies of items in a list.</strong> That
is, given a list, you want to know how many times each item appears. You can do this via
the following:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_freqs</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>  <span class="c"># happens O(n) times</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">freqs</span><span class="p">:</span>  <span class="c"># This check is O(1)! Wow!</span>
            <span class="n">freqs</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">freqs</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c"># Also O(1)! Wow!</span>
    <span class="k">return</span> <span class="n">freqs</span>
</code></pre></div></div>

<p>Try and think of how you’d do this <em>without</em> hashmaps. Probably, you’d sort the list,
and then look at adjacent values. But sorting is, at best <script type="math/tex">\mathcal{O}(\log n)</script>. This
solution does it in <script type="math/tex">\mathcal{O}(n)</script>!</p>

<p>Another classic problem that is solved with hashmaps is to <strong>find all repeated elements
in a list.</strong> This is really just a variant of the last, where you look for elements that
have frequency greater than 1.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_repeated</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">get_freqs</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">f</span> <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>Now, if you only need <em>one</em> repeated element, you can be efficient and just terminate on
the first one you find. For this, we’ll use a <code class="highlighter-rouge">set</code>, which is just a <code class="highlighter-rouge">dict</code> with values
of <code class="highlighter-rouge">None</code>. That is to say, <strong>sets are also hashmaps</strong>. The important thing to know is
that adding to them and checking if something is in them are both <script type="math/tex">\mathcal{O}(1)</script>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_repeated</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="n">items</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>  <span class="c"># happens O(n) times</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>  <span class="c"># This check is O(1)! Wow!</span>
            <span class="n">items</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">None</span>  <span class="c"># if this happens, all elements are unique</span>
</code></pre></div></div>

<p>The last one we’ll do is a bit trickier. You’re given a list of numbers, and a “target”,
and your task is to find a pair of numbers in the list that add up to the target. Try
and think for yourself how you’d do this - the fact you use hashmaps is a big hint. You
should be able to do it in <script type="math/tex">\mathcal{O}(n)</script>.</p>

<p>Have you thought about it? When I first encountered this one I had to look up the
answer. But here’s how you do it in <script type="math/tex">\mathcal{O}(n)</script>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_sum_pair</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">nums_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
        <span class="n">other_num</span> <span class="o">=</span> <span class="n">target</span><span class="o">-</span><span class="n">num</span>
        <span class="k">if</span> <span class="n">other_num</span> <span class="ow">in</span> <span class="n">nums_set</span><span class="p">:</span> 
            <span class="k">return</span> <span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">other_num</span><span class="p">)</span>
        <span class="n">nums_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>   <span class="c"># no-op if num is already there</span>
    <span class="k">return</span> <span class="bp">None</span>
</code></pre></div></div>

<p>Note that <code class="highlighter-rouge">other_num = target-num</code> is the number that you would need to complete the sum
pair; using a hashmap, you can check in <script type="math/tex">\mathcal{O}(1)</script> if you’ve already seen it!
Wow!</p>

<p>Hopefully you get it - hashmaps are cool. Go on LeetCode, or pop open <a href="https://www.amazon.com/Structures-Algorithms-Python-Michael-Goodrich/dp/1118290275/">your favorite
data structures book</a>, or even <a href="http://www.crackingthecodinginterview.com/">Cracking the Coding Interview</a>, and
get some practice with them.</p>

<h2 id="sorting--searching">Sorting &amp; Searching</h2>

<p>Sorting and searching are two of the basic tasks you have to be familiar with for any
coding interview. You can go into a lot of depth with these, but I’ll stick to the
basics here, because that’s what I find most helpful.</p>

<h3 id="sorting">Sorting</h3>

<p><strong>Sorting</strong> is a nice problem in that the statement of the problem is fairly
straightforward; given a list of numbers, reorder the list so that every element is less
than or equal to the next. There are a number of approaches to sorting. The naive
approach is called <a href="https://en.wikipedia.org/wiki/Insertion_sort"><strong>insertion sort</strong></a>; for example, it is what most people
do when sorting a hand of cards. It has some advantages, but is <script type="math/tex">\mathcal{O}(n^2)</script> in
time, and so is not the most efficient available.</p>

<p>The two most common fast sorting algorithms are <a href="https://en.wikipedia.org/wiki/Quicksort"><strong>quicksort</strong></a> and
<a href="https://en.wikipedia.org/wiki/Merge_sort"><strong>mergesort</strong></a>. They are both <script type="math/tex">\mathcal{O}(n \log n)</script> in
time,<sup id="fnref:fnote_sort"><a href="#fn:fnote_sort" class="footnote">11</a></sup> and so scale close-to-linearly with the size of the list. I won’t go
into the implementation details here; there are plenty of good discussions of them
available on the internet.</p>

<p>When thinking about sorting, it’s also worth considering space complexity -
can you sort without needing to carry around a second sorted copy of the list? If so,
that’s a significant advantage, especially for larger lists. It’s also worth thinking
about worst-case vs. average performance - how does the algorithm perform on a randomly
shuffled list, and how does it perform on a list specifically designed to take the
maximum number of steps for that algorithm to sort? Quicksort, for example, is actually
<script type="math/tex">\mathcal{O}(n^2)</script> in the worst case, but is <script type="math/tex">\mathcal{O}(n \log n)</script> on
average. Again, you can look to the <a href="https://www.bigocheatsheet.com/">big-O cheat sheet</a> to make sure you’re
remembering all your complexities correctly.</p>

<h3 id="searching">Searching</h3>

<p>The problem of <strong>searching</strong> is often stated as <strong>given a sorted list <code class="highlighter-rouge">l</code> and an object
<code class="highlighter-rouge">x</code>, find the index at which an element <code class="highlighter-rouge">x</code> lives.</strong> (You should immediately ask: What
should I return if <code class="highlighter-rouge">x</code> is not in <code class="highlighter-rouge">l</code>?)The name of the game here is <strong>binary
search</strong>. You basically split the list, then if the number is greater than the split,
search the top; otherwise, search the bottom. This is an example of a <em>recursive
algorithm</em>, so the way it’s written can be a bit opaque to those not used to looking at
recursive code. Once I can wrap my head around it, I find it quite elegant. The
important thing to know is that this search is <script type="math/tex">\mathcal{O}(\log n)</script>, which means that
you don’t touch every element in the list - it’s very fast, even for a large list. The
key to this is that the list is already sorted - if it’s not sorted, then you’re out of
luck; you’ve got to check every element to find <code class="highlighter-rouge">x</code>.</p>

<p>There are tons of examples of binary search in Python online, so I won’t put one
here. That said, I have found it interesting to see how thinking in terms of binary
search can help you in a variety of areas.</p>

<p>For example, suppose you had some eggs, and worked in a 40-story building, and wanted to
know the highest floor you could drop the egg off of without it breaking (it’s kind of a
dumb example cause the egg would probably break even on the first floor, but pretend
it’s a super-tough egg.) You could drop it from the first floor, and see what
happens. Say it doesn’t break. Then drop it from the 40th, and see what happens. Say it
does break. Then, you bisect and use the midpoint - drop from the 20th floor. If it
breaks here, you next try the 10th - if it doesn’t you next try the 30th. This allows
you to find the correct floor much faster than trying each floor in succession.</p>

<p>Sorting and searching are fundamental algorithms, and have been well studied for
decades. Having a basic fluency in them shows a familiarity with the field of computers
science that many employers like to see. In my opinion, <strong>you should be able to quickly
and easily implement the three sorting algorithms above, and binary search,</strong> in Python,
or whatever your language of choice is.</p>

<h1 id="working-with-sql">Working with SQL</h1>

<p>Finally, let’s talk a bit about SQL. SQL is a tool used to interact with so-called
“relational” databases, which just means that each row in a table has certain values
(columns), and that those values have the same type for each row (that is, the schema is
uniform throughout the table).<sup id="fnref:fnote_nosql"><a href="#fn:fnote_nosql" class="footnote">12</a></sup> It is not exactly a language, it’s more
like a family of languages. There are many “dialects” which all have slight differences,
but they behave the same with regards to core functionality; for example, you can do</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">column</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">WHERE</span> <span class="n">columns</span> <span class="o">=</span> <span class="s1">'value'</span>
</code></pre></div></div>

<p>in any SQL-like language.<sup id="fnref:fnote_ansi"><a href="#fn:fnote_ansi" class="footnote">13</a></sup> Modern data-storage and -access solutions like
Spark and Presto are very different from older databases in their underlying
architecture, but still use a SQL dialect for accessing data.</p>

<p>Solving problems in SQL involves thinking in a quite different way than solving a
similar problem on an array in Python. There is no real notion of iteration, or at least
it’s not easily accessible, so most of the complicated action happens via table joins. I
used <a href="https://sqlzoo.net/">SQLZoo</a>, and particularly the “assessments”, to practice my SQL and get it
up to snuff. LeetCode also has a SQL section (I think they call it “database”).</p>

<p>It’s essential to know SQL as a working data scientist. You’ll almost certainly use it
in your day-to-day activities. That said, it’s not always asked in the interviews, so
you might clarify with the company whether they will ask you SQL questions.</p>

<h2 id="a-note-on-dialects">A Note on Dialects</h2>

<p>There are many dialects of SQL, and changing the dialect changes things like (for
example) how you work with dates. It’s worth asking the company you’re interviewing with
what dialect they want you to know, if they have one in mind. If you’re just writing SQL
on a whiteboard, then I would be surprised if they were picky about this; I would just
say something like “here I’d use <code class="highlighter-rouge">DATE(table.dt_str)</code> or whatever the string-to-date
conversion function is in your dialect”. In this case it’s just details that move
around, but the big picture is generally the same for different dialects.</p>

<h1 id="conclusion">Conclusion</h1>

<p>Coding interviews are stressful. From what I can tell, that’s just the way it is. For
me, the best antidote to that is being well-prepared. I think companies are moving more
towards constructive, cooperative interview formats, and away from the classic Google
brain-teaser kind of questions, which helps with this, but you can still expect to be
challenged during these interviews.</p>

<p>Remember to be kind to yourself. You’ll probably fail many times before you
succeed. That’s fine, and is what happens to almost everyone. Just keep practicing, and
keep learning from your mistakes. Good luck!</p>

<!-------------------------------- FOOTER ---------------------------->

<div class="footnotes">
  <ol>
    <li id="fn:fnote_py3">
      <p>You should be using Python 3 at this point, but also be familiar with the
differences between 2 and 3, and be able to write code in Python 2 if need be. <a href="#fnref:fnote_py3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:fnote_parquet">
      <p>For “big data” stored in the cloud, an efficient format called Parquet
is the standard. In my experience, however, it’s uncommon to work with parquet files
directly in Pandas; you often read them into a distributed framework like Spark and work
with them in that context. <a href="#fnref:fnote_parquet" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:fnote_emacs">
      <p>The correct answer is, of course, emacs. <a href="#fnref:fnote_emacs" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:fnote_pyplot">
      <p><code class="highlighter-rouge">pyplot</code> is an API within matplotlib that was designed in order to
mimic the MATLAB plotting API. It is generally what I use; I begin most of my matplotlib
work with <code class="highlighter-rouge">from matplotlib import pyplot as plt</code>. I only rarely need to <code class="highlighter-rouge">import
matplotlib</code> direct, and that’s generally for configuration work. <a href="#fnref:fnote_pyplot" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:fnote_dsa2">
      <p>I read the book when preparing for a software engineer interview at
Google, so I picked up a lot more than was necessary for a data science interview. I
still find the material helpful, however, and it’s nice to be able to demonstrate
that you have gone above and beyond in a realm that data scientists sometimes
neglect (efficient software design). <a href="#fnref:fnote_dsa2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:fnote_dsa">
      <p>It goes well beyond what you’ll need for a data science interview,
however - it gets into tree structures, graphs (and graph traversal algorithms), and
other more advanced topics. I’d recommend focusing on complexity analysis, arrays,
and hashmaps as the most important data structures that a data scientist will use
day-to-day. <a href="#fnref:fnote_dsa" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:fnote_bigo">
      <p>This is only approximately true, or rather it is is <em>asymptotically</em>
true; this scaling law holds in the limit as <script type="math/tex">n\rightarrow\infty</script>. <a href="#fnref:fnote_bigo" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:fnote_asymptotics">
      <p>It’s a bit weird to use <em>both</em> <script type="math/tex">n</script> and <script type="math/tex">k</script> in your
complexity - mathematically, what this means is that we consider them separate
variables , and we can take the limit of either one independently from the
other. If, for example, you knew that <script type="math/tex">k = n/4</script>, so you always wanted the top
quarter of the list, then this would be <script type="math/tex">\mathcal{O}(n^2)</script>, since <script type="math/tex">n/4 =
\mathcal{O}(n)</script>. <a href="#fnref:fnote_asymptotics" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:fnote_linked">
      <p>I’m glossing over some details here - the numbers I quote above are for
a fixed-size array. So, if you build up an array by adding elements at the end, it
may seem like you get to just do a bunch of <script type="math/tex">\mathcal{O}(1)</script> <code class="highlighter-rouge">.append</code>s, but in
reality, you have to occasionally resize the array to make more space, which slows
things down to an average append time of <script type="math/tex">\mathcal{O}(n)</script>. If you want a list-like
type where inserting elements is easy (<script type="math/tex">\mathcal{O}(1)</script>) but accessing elements is
difficult (<script type="math/tex">\mathcal{O}(n)</script>), then you want a <em>linked list</em>. Linked lists aren’t
as important for data scientists to use, so I won’t get into them much here. <a href="#fnref:fnote_linked" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:fnote_array_hashmap">
      <p>You might wonder why we would ever use an array over a hashmap
if hashmaps are strictly superior with respect to their complexity. It’s a good
question. The answer is that arrays take up less space (they don’t have to store the
keys, only the values) and they are much easier to work with in code (they look
cleaner, and are more intuitive for unordered data). Furthermore, if you had a
hashmap that linked integers <code class="highlighter-rouge">0</code> through <code class="highlighter-rouge">10</code> to strings, and you wanted to change
the element at key <code class="highlighter-rouge">5</code>, then you’d have to go through what is currently at keys
<code class="highlighter-rouge">5</code> through <code class="highlighter-rouge">10</code>, and increment their keys by one, so you would end up back at an
inefficient insertion algorithm like you have with arrays. <a href="#fnref:fnote_array_hashmap" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:fnote_sort">
      <p>This is true <em>on average</em>; see the section below for a discussion of
average vs. worst-case complexity. <a href="#fnref:fnote_sort" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:fnote_nosql">
      <p>Non-relational database formats, like HBase and NoSQL, basically
function like giant hashmaps; they have a single “key”, and then the “value” can
contain arbitrary data - you don’t have to have certain columns in there. The
advantage of this is flexibility, but the disadvantage is that sorting and filtering
are slower because the database doesn’t have a pre-defined schema. <a href="#fnref:fnote_nosql" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:fnote_ansi">
      <p>Technically, SQL is an ANSI Standard that many different dialects
implement - so, to call yourself a SQL dialect, you must have features defined by
this standard, like the <code class="highlighter-rouge">SELECT</code>, <code class="highlighter-rouge">FROM</code>, and <code class="highlighter-rouge">WHERE</code> clauses shown above. <a href="#fnref:fnote_ansi" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2019-08-29T00:00:00+05:30">August 29, 2019</time></p>

      </footer>

      

      
  <nav class="pagination">
    
      <a href="/posts/2019/08/24/stats.html" class="pagination--pager" title="DS Interview Study Guide Part I: Statistics
">Previous</a>
    
    
      <a href="/posts/2019/09/20/bogus.html" class="pagination--pager" title="Your p-values Are Bogus
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
</div>
    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 Ramya Bygari. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="http://localhost:4000/assets/js/main.min.js"></script>








<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>




  </body>
</html>
